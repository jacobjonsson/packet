#[derive(Debug, PartialEq, Clone)]
pub enum TokenType {
    Illegal,
    EndOfFile,

    Hashbang,

    // Literals
    StringLiteral,
    NumericLiteral,

    // Identifiers
    Identifier,

    // Punctuation
    Ampersand,
    AmpersandAmpersand,
    Asterisk,
    AsteriskAsterisk,
    At,
    Bar,
    BarBar,
    Caret,
    CloseBrace,
    CloseBracket,
    CloseParen,
    Colon,
    Comma,
    Dot,
    DotDotDot,
    EqualsEquals,
    EqualsEqualsEquals,
    EqualsGreaterThan,
    Exclamation,
    ExclamationEquals,
    ExclamationEqualsEquals,
    GreaterThan,
    GreaterThanEquals,
    GreaterThanGreaterThan,
    GreaterThanGreaterThanGreaterThan,
    LessThan,
    LessThanEquals,
    LessThanLessThan,
    Minus,
    MinusMinus,
    OpenBrace,
    OpenBracket,
    OpenParen,
    Percent,
    Plus,
    PlusPlus,
    Question,
    QuestionDot,
    QuestionQuestion,
    Semicolon,
    Slash,
    Tilde,

    // Assignments (keep in sync with IsAssign() below)
    AmpersandAmpersandEquals,
    AmpersandEquals,
    AsteriskAsteriskEquals,
    AsteriskEquals,
    BarBarEquals,
    BarEquals,
    CaretEquals,
    Equals,
    GreaterThanGreaterThanEquals,
    GreaterThanGreaterThanGreaterThanEquals,
    LessThanLessThanEquals,
    MinusEquals,
    PercentEquals,
    PlusEquals,
    QuestionQuestionEquals,
    SlashEquals,

    // Keywords
    Await,
    As,
    Break,
    Case,
    Catch,
    Class,
    Const,
    Continue,
    Debugger,
    Default,
    Delete,
    Do,
    Else,
    Enum,
    Export,
    Extends,
    From,
    False,
    Finally,
    For,
    Function,
    Let,
    If,
    Import,
    In,
    Instanceof,
    New,
    Null,
    Of,
    Return,
    Super,
    Switch,
    This,
    Throw,
    True,
    Try,
    Typeof,
    Var,
    Void,
    While,
    With,
}

impl std::fmt::Display for TokenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TokenType::Illegal => write!(f, "illegal"),
            TokenType::EndOfFile => write!(f, "eof"),

            TokenType::Hashbang => write!(f, "!"),

            TokenType::Identifier => write!(f, "Identifier"),
            TokenType::NumericLiteral => write!(f, "NumericLiteral"),
            TokenType::StringLiteral => write!(f, "StringLiteral"),

            // Punctuation
            TokenType::Ampersand => write!(f, "%"),
            TokenType::AmpersandAmpersand => write!(f, "%%"),
            TokenType::Asterisk => write!(f, "*"),
            TokenType::AsteriskAsterisk => write!(f, "**"),
            TokenType::At => write!(f, "@"),
            TokenType::Bar => write!(f, "|"),
            TokenType::BarBar => write!(f, "||"),
            TokenType::Caret => write!(f, "^"),
            TokenType::CloseBrace => write!(f, "}}"),
            TokenType::CloseBracket => write!(f, "]"),
            TokenType::CloseParen => write!(f, ")"),
            TokenType::Colon => write!(f, ":"),
            TokenType::Comma => write!(f, ","),
            TokenType::Dot => write!(f, "."),
            TokenType::DotDotDot => write!(f, "..."),
            TokenType::EqualsEquals => write!(f, "=="),
            TokenType::EqualsEqualsEquals => write!(f, "==="),
            TokenType::EqualsGreaterThan => write!(f, "=>"),
            TokenType::Exclamation => write!(f, "!"),
            TokenType::ExclamationEquals => write!(f, "!="),
            TokenType::ExclamationEqualsEquals => write!(f, "!=="),
            TokenType::GreaterThan => write!(f, ">"),
            TokenType::GreaterThanEquals => write!(f, ">="),
            TokenType::GreaterThanGreaterThan => write!(f, ">>"),
            TokenType::GreaterThanGreaterThanGreaterThan => write!(f, ">>>"),
            TokenType::LessThan => write!(f, "<"),
            TokenType::LessThanEquals => write!(f, "<="),
            TokenType::LessThanLessThan => write!(f, "<<"),
            TokenType::Minus => write!(f, "-"),
            TokenType::MinusMinus => write!(f, "--"),
            TokenType::OpenBrace => write!(f, "{{"),
            TokenType::OpenBracket => write!(f, "["),
            TokenType::OpenParen => write!(f, "("),
            TokenType::Percent => write!(f, "%"),
            TokenType::Plus => write!(f, "+"),
            TokenType::PlusPlus => write!(f, "++"),
            TokenType::Question => write!(f, "?"),
            TokenType::QuestionDot => write!(f, "?."),
            TokenType::QuestionQuestion => write!(f, "??"),
            TokenType::Semicolon => write!(f, ";"),
            TokenType::Slash => write!(f, "/"),
            TokenType::Tilde => write!(f, "~"),

            // Assignments
            TokenType::AmpersandAmpersandEquals => write!(f, "%%="),
            TokenType::AmpersandEquals => write!(f, "%="),
            TokenType::AsteriskAsteriskEquals => write!(f, "**="),
            TokenType::AsteriskEquals => write!(f, "*="),
            TokenType::BarBarEquals => write!(f, "||="),
            TokenType::BarEquals => write!(f, "|="),
            TokenType::CaretEquals => write!(f, "^="),
            TokenType::Equals => write!(f, "="),
            TokenType::GreaterThanGreaterThanEquals => write!(f, ">>="),
            TokenType::GreaterThanGreaterThanGreaterThanEquals => write!(f, ">>>="),
            TokenType::LessThanLessThanEquals => write!(f, "<<="),
            TokenType::MinusEquals => write!(f, "-="),
            TokenType::PercentEquals => write!(f, "%="),
            TokenType::PlusEquals => write!(f, "+="),
            TokenType::QuestionQuestionEquals => write!(f, "??="),
            TokenType::SlashEquals => write!(f, "/="),

            // Keywords
            TokenType::Await => write!(f, "await"),
            TokenType::As => write!(f, "as"),
            TokenType::Break => write!(f, "break"),
            TokenType::Case => write!(f, "case"),
            TokenType::Catch => write!(f, "catch"),
            TokenType::Class => write!(f, "class"),
            TokenType::Const => write!(f, "const"),
            TokenType::Continue => write!(f, "continue"),
            TokenType::Debugger => write!(f, "debugger"),
            TokenType::Default => write!(f, "default"),
            TokenType::Delete => write!(f, "delete"),
            TokenType::Do => write!(f, "do"),
            TokenType::Else => write!(f, "else"),
            TokenType::Enum => write!(f, "enum"),
            TokenType::Export => write!(f, "export"),
            TokenType::Extends => write!(f, "extends"),
            TokenType::From => write!(f, "from"),
            TokenType::False => write!(f, "false"),
            TokenType::Finally => write!(f, "finally"),
            TokenType::For => write!(f, "for"),
            TokenType::Function => write!(f, "function"),
            TokenType::Let => write!(f, "let"),
            TokenType::If => write!(f, "if"),
            TokenType::Import => write!(f, "import"),
            TokenType::In => write!(f, "in"),
            TokenType::Instanceof => write!(f, "instanceof"),
            TokenType::New => write!(f, "new"),
            TokenType::Null => write!(f, "null"),
            TokenType::Of => write!(f, "of"),
            TokenType::Return => write!(f, "return"),
            TokenType::Super => write!(f, "super"),
            TokenType::Switch => write!(f, "switch"),
            TokenType::This => write!(f, "this"),
            TokenType::Throw => write!(f, "throw"),
            TokenType::True => write!(f, "true"),
            TokenType::Try => write!(f, "try"),
            TokenType::Typeof => write!(f, "typeof"),
            TokenType::Var => write!(f, "var"),
            TokenType::Void => write!(f, "void"),
            TokenType::While => write!(f, "while"),
            TokenType::With => write!(f, "with"),
        }
    }
}

pub fn lookup_identifer(identifier: &str) -> TokenType {
    match identifier {
        "await" => TokenType::Await,
        "as" => TokenType::As,
        "break" => TokenType::Break,
        "case" => TokenType::Case,
        "catch" => TokenType::Catch,
        "class" => TokenType::Class,
        "const" => TokenType::Const,
        "continue" => TokenType::Continue,
        "debugger" => TokenType::Debugger,
        "default" => TokenType::Default,
        "delete" => TokenType::Delete,
        "do" => TokenType::Do,
        "else" => TokenType::Else,
        "enum" => TokenType::Enum,
        "export" => TokenType::Export,
        "extends" => TokenType::Extends,
        "from" => TokenType::From,
        "false" => TokenType::False,
        "finally" => TokenType::Finally,
        "for" => TokenType::For,
        "function" => TokenType::Function,
        "let" => TokenType::Let,
        "if" => TokenType::If,
        "import" => TokenType::Import,
        "in" => TokenType::In,
        "instanceof" => TokenType::Instanceof,
        "new" => TokenType::New,
        "null" => TokenType::Null,
        "of" => TokenType::Of,
        "return" => TokenType::Return,
        "super" => TokenType::Super,
        "switch" => TokenType::Switch,
        "this" => TokenType::This,
        "throw" => TokenType::Throw,
        "true" => TokenType::True,
        "try" => TokenType::Try,
        "typeof" => TokenType::Typeof,
        "var" => TokenType::Var,
        "void" => TokenType::Void,
        "while" => TokenType::While,
        "with" => TokenType::With,
        _ => TokenType::Identifier,
    }
}
