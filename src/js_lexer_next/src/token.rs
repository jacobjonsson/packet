#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    Illegal,
    Eof,

    // Literals
    BigInt {
        value: String,
    },
    Number {
        value: f64,
    },
    String {
        value: String,
    },

    NoSubstationTemplate {
        value: String,
    },

    TemplateHead {
        value: String,
    },
    TemplateMiddle {
        value: String,
    },
    TemplateTail {
        value: String,
    },

    Regexp {
        pattern: String,
        flags: Option<String>,
    },

    // Identifiers
    Identifier {
        name: String,
    },

    // Punctuation
    Ampersand,
    AmpersandAmpersand,
    Asterisk,
    AsteriskAsterisk,
    Bar,
    BarBar,
    Caret,
    CloseBrace,
    CloseBracket,
    CloseParen,
    Colon,
    Comma,
    Dot,
    DotDotDot,
    EqualsEquals,
    EqualsEqualsEquals,
    EqualsGreaterThan,
    Exclamation,
    ExclamationEquals,
    ExclamationEqualsEquals,
    GreaterThan,
    GreaterThanEquals,
    GreaterThanGreaterThan,
    GreaterThanGreaterThanGreaterThan,
    LessThan,
    LessThanEquals,
    LessThanLessThan,
    Minus,
    MinusMinus,
    OpenBrace,
    OpenBracket,
    OpenParen,
    Percent,
    Plus,
    PlusPlus,
    Question,
    QuestionDot,
    QuestionQuestion,
    Semicolon,
    Slash,
    Tilde,

    // Assignments
    AmpersandAmpersandEquals,
    AmpersandEquals,
    AsteriskAsteriskEquals,
    AsteriskEquals,
    BarBarEquals,
    BarEquals,
    CaretEquals,
    Equals,
    GreaterThanGreaterThanEquals,
    GreaterThanGreaterThanGreaterThanEquals,
    LessThanLessThanEquals,
    MinusEquals,
    PercentEquals,
    PlusEquals,
    QuestionQuestionEquals,
    SlashEquals,

    // Reserved words
    Break,
    Case,
    Catch,
    Class,
    Const,
    Continue,
    Debugger,
    Default,
    Delete,
    Do,
    Else,
    Enum,
    Export,
    Extends,
    False,
    Finally,
    For,
    Function,
    If,
    Import,
    In,
    Instanceof,
    New,
    Null,
    Return,
    Super,
    Switch,
    This,
    Throw,
    True,
    Try,
    Typeof,
    Var,
    Void,
    While,
    With,
}

/// Checks if the given identifier is a keyword
pub fn lookup_keyword(identifier: &str) -> Option<Token> {
    match identifier {
        "break" => Some(Token::Break),
        "case" => Some(Token::Case),
        "catch" => Some(Token::Catch),
        "class" => Some(Token::Class),
        "const" => Some(Token::Const),
        "continue" => Some(Token::Continue),
        "debugger" => Some(Token::Debugger),
        "default" => Some(Token::Default),
        "delete" => Some(Token::Delete),
        "do" => Some(Token::Do),
        "else" => Some(Token::Else),
        "enum" => Some(Token::Enum),
        "export" => Some(Token::Export),
        "extends" => Some(Token::Extends),
        "false" => Some(Token::False),
        "finally" => Some(Token::Finally),
        "for" => Some(Token::For),
        "function" => Some(Token::Function),
        "if" => Some(Token::If),
        "import" => Some(Token::Import),
        "in" => Some(Token::In),
        "instanceof" => Some(Token::Instanceof),
        "new" => Some(Token::New),
        "null" => Some(Token::Null),
        "return" => Some(Token::Return),
        "super" => Some(Token::Super),
        "switch" => Some(Token::Switch),
        "this" => Some(Token::This),
        "throw" => Some(Token::Throw),
        "true" => Some(Token::True),
        "try" => Some(Token::Try),
        "typeof" => Some(Token::Typeof),
        "var" => Some(Token::Var),
        "void" => Some(Token::Void),
        "while" => Some(Token::While),
        "with" => Some(Token::With),
        _ => None,
    }
}
